"""Auto-refactored module: file_input"""
from .logging import logger

import os
import asyncio
import time
import traceback
import logging
import random
import math
import json
import tempfile
import shutil
from datetime import datetime, timedelta
from typing import Dict, List, Tuple, Any, Optional, Callable, Awaitable
from pathlib import Path
import aiohttp
from ..constants import (
    TimeConstants, InstagramTexts, BrowserConfig, Limits, TaskStatus, LogCategories, FilePaths,
    VerboseFilters, InstagramSelectors, APIConstants
)
from ..selectors_config import InstagramSelectors as SelectorConfig, SelectorUtils
from ..task_utils import (
    update_task_log, update_account_task, update_task_status, get_account_username,
    get_account_from_task, mark_account_as_used, get_task_with_accounts, 
    get_account_tasks, get_assigned_videos, get_all_task_videos, get_all_task_titles,
    handle_verification_error, handle_task_completion, handle_emergency_cleanup,
    process_browser_result, handle_account_task_error, handle_critical_task_error
)
from ..account_utils import (
    get_account_details, get_proxy_details, get_account_proxy,
    get_account_dolphin_profile_id, save_dolphin_profile_id
)
from ..browser_support import (
    cleanup_hanging_browser_processes, safely_close_all_windows,
    simulate_human_rest_behavior, simulate_normal_browsing_behavior,
    simulate_extended_human_rest_behavior
)
from ..instagram_automation import InstagramNavigator, InstagramUploader, InstagramLoginHandler
from ..browser_utils import BrowserManager, PageUtils, ErrorHandler, NetworkUtils, FileUtils, DebugUtils
from ..crop_handler import CropHandler, handle_crop_and_aspect_ratio
from ..logging_utils import log_info, log_error, log_debug, log_warning
from ..human_behavior import AdvancedHumanBehavior, init_human_behavior, get_human_behavior
from ..captcha_solver import solve_recaptcha_if_present, detect_recaptcha_on_page, solve_recaptcha_if_present_sync
from ..email_verification_async import (
    get_email_verification_code_async,
    get_2fa_code_async,
    determine_verification_type_async
)
import django
from ..models import InstagramAccount, BulkUploadAccount


async def check_for_file_dialog_async(page) -> bool:
    """Check if file selection dialog is open - –ü–û–õ–ù–ê–Ø –ö–û–ü–ò–Ø –∏–∑ sync InstagramNavigator._check_for_file_dialog()"""
    try:
        log_info("[ASYNC_UPLOAD] [SEARCH] Checking for file dialog...")
        
        # Use comprehensive file input selectors (–ü–û–õ–ù–ê–Ø –ö–û–ü–ò–Ø –∏–∑ sync)
        for selector in SelectorConfig.FILE_INPUT:
            try:
                if selector.startswith('//'):
                    elements = await page.query_selector_all(f"xpath={selector}")
                else:
                    elements = await page.query_selector_all(selector)
                
                for element in elements:
                    if await element.is_visible():
                        log_info(f"[ASYNC_UPLOAD] [OK] File dialog indicator found: {selector}")
                        return True
            except Exception as e:
                log_info(f"[ASYNC_UPLOAD] Selector failed: {selector} - {str(e)}")
                continue
        
        # Check URL for create mode (–ü–û–õ–ù–ê–Ø –ö–û–ü–ò–Ø –∏–∑ sync)
        try:
            current_url = page.url
            if 'create' in current_url.lower():
                log_info(f"[ASYNC_UPLOAD] [SEARCH] URL indicates create mode: {current_url}")
                return True
        except:
            pass
        
        # Check page content for upload indicators (–ü–û–õ–ù–ê–Ø –ö–û–ü–ò–Ø –∏–∑ sync)
        try:
            page_text = await page.inner_text('body') or ""
            upload_keywords = [
                '–≤—ã–±—Ä–∞—Ç—å –Ω–∞ –∫–æ–º–ø—å—é—Ç–µ—Ä–µ', 'select from computer', 'seleccionar desde el ordenador', 'seleccionar desde la computadora', 'selecionar do computador',
                '–≤—ã–±—Ä–∞—Ç—å —Ñ–∞–π–ª—ã', 'select files', 'seleccionar archivos', 'selecionar arquivos',
                '–ø–µ—Ä–µ—Ç–∞—â–∏—Ç–µ —Ñ–∞–π–ª—ã', 'drag files', 'arrastra los archivos', 'arrastar arquivos',
                '–∑–∞–≥—Ä—É–∑–∏—Ç—å —Ñ–∞–π–ª', 'upload file', 'subir archivo', 'carregar arquivo'
            ]
            
            for keyword in upload_keywords:
                if keyword in page_text.lower():
                    log_info(f"[ASYNC_UPLOAD] [OK] Upload interface detected via keyword: '{keyword}'")
                    return True
        except:
            pass
        
        log_info("[ASYNC_UPLOAD] [FAIL] No file dialog detected")
        return False
        
    except Exception as e:
        log_info(f"[ASYNC_UPLOAD] Error checking for file dialog: {str(e)}")
        return False

async def find_file_input_adaptive_async(page):
    """–ê–¥–∞–ø—Ç–∏–≤–Ω—ã–π –ø–æ–∏—Å–∫ —Ñ–∞–π–ª–æ–≤–æ–≥–æ input - –ü–û–õ–ù–ê–Ø –ö–û–ü–ò–Ø sync –≤–µ—Ä—Å–∏–∏"""
    try:
        log_info("[ASYNC_UPLOAD] [SEARCH] Starting adaptive file input search...")
        
        # [TARGET] –°–¢–†–ê–¢–ï–ì–ò–Ø 1: –ü–æ–∏—Å–∫ –ø–æ —Å–µ–º–∞–Ω—Ç–∏—á–µ—Å–∫–∏–º –∞—Ç—Ä–∏–±—É—Ç–∞–º (–ü–û–õ–ù–ê–Ø –ö–û–ü–ò–Ø –∏–∑ sync)
        log_info("[ASYNC_UPLOAD] [CLIPBOARD] Strategy 1: Semantic attributes search...")
        semantic_strategies = [
            'input[type="file"]',
            'input[accept*="video"]',
            'input[accept*="image"]', 
            'input[accept*="mp4"]',
            'input[accept*="quicktime"]',
            'input[multiple]',
            'form[enctype="multipart/form-data"] input[type="file"]',
            'form[method="POST"] input[type="file"]',
        ]
        
        for selector in semantic_strategies:
            try:
                elements = await page.query_selector_all(selector)
                log_info(f"[ASYNC_UPLOAD] üîé Checking selector: {selector} - found {len(elements)} elements")
                
                for element in elements:
                    if element and await is_valid_file_input_async(element):
                        log_info(f"[ASYNC_UPLOAD] [OK] Found file input via semantic: {selector}")
                        return element
            except Exception as e:
                log_info(f"[ASYNC_UPLOAD] Semantic selector failed: {selector} - {str(e)}")
                continue
        
        # [TARGET] –°–¢–†–ê–¢–ï–ì–ò–Ø 2: –ü–æ–∏—Å–∫ —á–µ—Ä–µ–∑ —Å—Ç—Ä—É–∫—Ç—É—Ä—É –¥–∏–∞–ª–æ–≥–∞ (–ü–û–õ–ù–ê–Ø –ö–û–ü–ò–Ø –∏–∑ sync)
        log_info("[ASYNC_UPLOAD] üèóÔ∏è Strategy 2: Dialog structure search...")
        dialog_input = await find_input_via_dialog_structure_async(page)
        if dialog_input:
            log_info("[ASYNC_UPLOAD] [OK] Found file input via dialog structure")
            return dialog_input
        
        # [TARGET] –°–¢–†–ê–¢–ï–ì–ò–Ø 3: –ü–æ–∏—Å–∫ —á–µ—Ä–µ–∑ –∫–Ω–æ–ø–∫—É "–í—ã–±—Ä–∞—Ç—å –Ω–∞ –∫–æ–º–ø—å—é—Ç–µ—Ä–µ" (–ü–û–õ–ù–ê–Ø –ö–û–ü–ò–Ø –∏–∑ sync)
        log_info("[ASYNC_UPLOAD] üîò Strategy 3: Button-based search...")
        button_input = await find_input_via_button_async(page)
        if button_input:
            log_info("[ASYNC_UPLOAD] [OK] Found file input via button search")
            return button_input
        
        # [TARGET] –°–¢–†–ê–¢–ï–ì–ò–Ø 4: –ü–æ–∏—Å–∫ –ø–æ –∫–æ–Ω—Ç–µ–∫—Å—Ç—É —Ñ–æ—Ä–º—ã (–ü–û–õ–ù–ê–Ø –ö–û–ü–ò–Ø –∏–∑ sync)
        log_info("[ASYNC_UPLOAD] [TEXT] Strategy 4: Form context search...")
        form_input = await find_input_via_form_context_async(page)
        if form_input:
            log_info("[ASYNC_UPLOAD] [OK] Found file input via form context")
            return form_input
        
        # [TARGET] –°–¢–†–ê–¢–ï–ì–ò–Ø 5: –ü–æ–∏—Å–∫ –ø–æ —Ö–∞—Ä–∞–∫—Ç–µ—Ä–Ω—ã–º CSS-–∫–ª–∞—Å—Å–∞–º Instagram (–ü–û–õ–ù–ê–Ø –ö–û–ü–ò–Ø –∏–∑ sync)
        log_info("[ASYNC_UPLOAD] üé® Strategy 5: Instagram CSS patterns...")
        css_input = await find_input_via_css_patterns_async(page)
        if css_input:
            log_info("[ASYNC_UPLOAD] [OK] Found file input via CSS patterns")
            return css_input
        
        # [TARGET] –°–¢–†–ê–¢–ï–ì–ò–Ø 6: –®–∏—Ä–æ–∫–∏–π –ø–æ–∏—Å–∫ –≤—Å–µ—Ö input –∏ —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏—è (–ü–û–õ–ù–ê–Ø –ö–û–ü–ò–Ø –∏–∑ sync)
        log_info("[ASYNC_UPLOAD] üåê Strategy 6: Broad search with filtering...")
        all_input = await find_input_via_broad_search_async(page)
        if all_input:
            log_info("[ASYNC_UPLOAD] [OK] Found file input via broad search")
            return all_input
            
        log_info("[ASYNC_UPLOAD] [WARN] No file input found with any adaptive strategy")
        return None
        
    except Exception as e:
        log_info(f"[ASYNC_UPLOAD] [FAIL] Adaptive file input search failed: {str(e)}")
        return None

async def is_valid_file_input_async(element):
    """–ü—Ä–æ–≤–µ—Ä–∏—Ç—å, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —ç–ª–µ–º–µ–Ω—Ç –≤–∞–ª–∏–¥–Ω—ã–º —Ñ–∞–π–ª–æ–≤—ã–º input - –ü–û–õ–ù–ê–Ø –ö–û–ü–ò–Ø sync –≤–µ—Ä—Å–∏–∏"""
    try:
        if not element:
            return False
            
        # –ü—Ä–æ–≤–µ—Ä–∏—Ç—å —Ç–∏–ø (–ü–û–õ–ù–ê–Ø –ö–û–ü–ò–Ø –∏–∑ sync)
        input_type = await element.get_attribute('type')
        if input_type != 'file':
            return False
        
        # –ü—Ä–æ–≤–µ—Ä–∏—Ç—å accept –∞—Ç—Ä–∏–±—É—Ç (–ü–û–õ–ù–ê–Ø –ö–û–ü–ò–Ø –∏–∑ sync)
        accept_attr = await element.get_attribute('accept') or ""
        
        log_info(f"[ASYNC_UPLOAD] Validating input: type='{input_type}', accept='{accept_attr}'")
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ accept —Å–æ–¥–µ—Ä–∂–∏—Ç –Ω—É–∂–Ω—ã–µ —Ç–∏–ø—ã —Ñ–∞–π–ª–æ–≤ (–ü–û–õ–ù–ê–Ø –ö–û–ü–ò–Ø –∏–∑ sync)
        valid_types = ['video', 'image', 'mp4', 'jpeg', 'png', 'quicktime', 'heic', 'heif', 'avif']
        if accept_attr and not any(file_type in accept_attr.lower() for file_type in valid_types):
            log_info(f"[ASYNC_UPLOAD] Input rejected: accept attribute doesn't contain valid file types")
            return False
        
        # –ï—Å–ª–∏ accept –ø—É—Å—Ç–æ–π, –Ω–æ —ç—Ç–æ input[type="file"], —Å—á–∏—Ç–∞–µ–º –≤–∞–ª–∏–¥–Ω—ã–º (–ü–û–õ–ù–ê–Ø –ö–û–ü–ò–Ø –∏–∑ sync)
        if not accept_attr:
            log_info("[ASYNC_UPLOAD] Input has no accept attribute, but type='file' - considering valid")
        
        # –ü—Ä–æ–≤–µ—Ä–∏—Ç—å multiple –∞—Ç—Ä–∏–±—É—Ç (–ü–û–õ–ù–ê–Ø –ö–û–ü–ò–Ø –∏–∑ sync)
        multiple_attr = await element.get_attribute('multiple')
        if multiple_attr is not None:
            log_info("[ASYNC_UPLOAD] Input supports multiple files - good sign")
        
        log_info("[ASYNC_UPLOAD] Input validation passed")
        return True
            
    except Exception as e:
        log_info(f"[ASYNC_UPLOAD] Error validating file input: {str(e)}")
        return False

async def find_input_via_dialog_structure_async(page):
    """–ù–∞–π—Ç–∏ input —á–µ—Ä–µ–∑ —Å—Ç—Ä—É–∫—Ç—É—Ä—É –¥–∏–∞–ª–æ–≥–∞ - –ü–û–õ–ù–ê–Ø –ö–û–ü–ò–Ø sync –≤–µ—Ä—Å–∏–∏"""
    try:
        log_info("[ASYNC_UPLOAD] üèóÔ∏è Searching within dialog structure...")
        
        # –°–µ–ª–µ–∫—Ç–æ—Ä—ã –¥–ª—è –¥–∏–∞–ª–æ–≥–∞ —Å–æ–∑–¥–∞–Ω–∏—è –ø—É–±–ª–∏–∫–∞—Ü–∏–∏ (–ü–û–õ–ù–ê–Ø –ö–û–ü–ò–Ø –∏–∑ sync)
        dialog_selectors = [
            'div[aria-label="–°–æ–∑–¥–∞–Ω–∏–µ –ø—É–±–ª–∏–∫–∞—Ü–∏–∏"]',
            'div[aria-label*="–°–æ–∑–¥–∞–Ω–∏–µ"]',
            'div[role="dialog"]',
            'div:has-text("–°–æ–∑–¥–∞–Ω–∏–µ –ø—É–±–ª–∏–∫–∞—Ü–∏–∏")',
            'div:has-text("–ü–µ—Ä–µ—Ç–∞—â–∏—Ç–µ —Å—é–¥–∞ —Ñ–æ—Ç–æ –∏ –≤–∏–¥–µ–æ")',
            'div:has-text("–í—ã–±—Ä–∞—Ç—å –Ω–∞ –∫–æ–º–ø—å—é—Ç–µ—Ä–µ")',
        ]
        
        for selector in dialog_selectors:
            try:
                dialog = await page.query_selector(selector)
                if dialog:
                    log_info(f"[ASYNC_UPLOAD] üèóÔ∏è Found dialog with: {selector}")
                    
                    # –ò—â–µ–º input –≤–Ω—É—Ç—Ä–∏ –¥–∏–∞–ª–æ–≥–∞ (–ü–û–õ–ù–ê–Ø –ö–û–ü–ò–Ø –∏–∑ sync)
                    file_input = await dialog.query_selector('input[type="file"]')
                    if file_input and await is_valid_file_input_async(file_input):
                        log_info("[ASYNC_UPLOAD] [OK] Found valid file input inside dialog")
                        return file_input
                    
                    # –¢–∞–∫–∂–µ –ø—Ä–æ–≤–µ—Ä—è–µ–º form –≤–Ω—É—Ç—Ä–∏ –¥–∏–∞–ª–æ–≥–∞ (–ü–û–õ–ù–ê–Ø –ö–û–ü–ò–Ø –∏–∑ sync)
                    form = await dialog.query_selector('form')
                    if form:
                        form_input = await form.query_selector('input[type="file"]')
                        if form_input and await is_valid_file_input_async(form_input):
                            log_info("[ASYNC_UPLOAD] [OK] Found valid file input inside form within dialog")
                            return form_input
                            
            except Exception as e:
                log_info(f"[ASYNC_UPLOAD] Dialog selector failed {selector}: {str(e)}")
                continue
                
        return None
    except Exception as e:
        log_info(f"[ASYNC_UPLOAD] Dialog structure search failed: {str(e)}")
        return None

async def find_input_via_button_async(page):
    """–ù–∞–π—Ç–∏ input —á–µ—Ä–µ–∑ –∫–Ω–æ–ø–∫—É - –ü–û–õ–ù–ê–Ø –ö–û–ü–ò–Ø sync –≤–µ—Ä—Å–∏–∏"""
    try:
        button_selectors = [
            'button:has-text("–í—ã–±—Ä–∞—Ç—å –Ω–∞ –∫–æ–º–ø—å—é—Ç–µ—Ä–µ")',
            'button:has-text("Select from computer")',
            'button:has-text("–í—ã–±—Ä–∞—Ç—å —Ñ–∞–π–ª—ã")',
            'button:has-text("Select files")',
        ]
        
        for selector in button_selectors:
            try:
                button = await page.query_selector(selector)
                if button and await button.is_visible():
                    # –ò—â–µ–º input –≤ —Ç–æ–º –∂–µ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–µ (–ü–û–õ–ù–ê–Ø –ö–û–ü–ò–Ø –∏–∑ sync)
                    parent = button
                    for _ in range(5):  # –ü–æ–¥–Ω–∏–º–∞–µ–º—Å—è –¥–æ 5 —É—Ä–æ–≤–Ω–µ–π –≤–≤–µ—Ä—Ö
                        try:
                            parent = await parent.query_selector('xpath=..')
                            if parent:
                                file_input = await parent.query_selector('input[type="file"]')
                                if file_input:
                                    return file_input
                        except:
                            break
            except Exception as e:
                log_info(f"[ASYNC_UPLOAD] Button search failed for {selector}: {str(e)}")
                continue
        return None
    except Exception as e:
        log_info(f"[ASYNC_UPLOAD] Button-based search failed: {str(e)}")
        return None

async def find_input_via_form_context_async(page):
    """–ù–∞–π—Ç–∏ input —á–µ—Ä–µ–∑ –∫–æ–Ω—Ç–µ–∫—Å—Ç —Ñ–æ—Ä–º—ã - –ü–û–õ–ù–ê–Ø –ö–û–ü–ò–Ø sync –≤–µ—Ä—Å–∏–∏"""
    try:
        # –ò—â–µ–º —Ñ–æ—Ä–º—ã —Å multipart/form-data (–ü–û–õ–ù–ê–Ø –ö–û–ü–ò–Ø –∏–∑ sync)
        forms = await page.query_selector_all('form[enctype="multipart/form-data"]')
        for form in forms:
            file_input = await form.query_selector('input[type="file"]')
            if file_input and await is_valid_file_input_async(file_input):
                return file_input
        
        # –ò—â–µ–º —Ñ–æ—Ä–º—ã —Å method="POST" (–ü–û–õ–ù–ê–Ø –ö–û–ü–ò–Ø –∏–∑ sync)
        forms = await page.query_selector_all('form[method="POST"]')
        for form in forms:
            file_input = await form.query_selector('input[type="file"]')
            if file_input and await is_valid_file_input_async(file_input):
                return file_input
                
        return None
    except Exception as e:
        log_info(f"[ASYNC_UPLOAD] Form context search failed: {str(e)}")
        return None

async def find_input_via_css_patterns_async(page):
    """–ü–æ–∏—Å–∫ –ø–æ —Ö–∞—Ä–∞–∫—Ç–µ—Ä–Ω—ã–º CSS-–ø–∞—Ç—Ç–µ—Ä–Ω–∞–º Instagram - –ü–û–õ–ù–ê–Ø –ö–û–ü–ò–Ø sync –≤–µ—Ä—Å–∏–∏"""
    try:
        # –ü–∞—Ç—Ç–µ—Ä–Ω—ã CSS-–∫–ª–∞—Å—Å–æ–≤ Instagram –¥–ª—è —Ñ–∞–π–ª–æ–≤—ã—Ö input (–ü–û–õ–ù–ê–Ø –ö–û–ü–ò–Ø –∏–∑ sync)
        css_patterns = [
            # –¢–æ—á–Ω—ã–π –∫–ª–∞—Å—Å –∏–∑ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª–µ–Ω–Ω–æ–≥–æ HTML
            'input._ac69',
            # –ü–∞—Ç—Ç–µ—Ä–Ω—ã –∫–ª–∞—Å—Å–æ–≤ Instagram
            'input[class*="_ac69"]',
            'input[class*="_ac"]', 
            'input[class*="_ac"]',
            # –ö–æ–º–±–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ —Å–µ–ª–µ–∫—Ç–æ—Ä—ã
            'form input[class*="_ac"]',
            'form[role="presentation"] input',
            'form[enctype="multipart/form-data"] input',
        ]
        
        for pattern in css_patterns:
            try:
                elements = await page.query_selector_all(pattern)
                log_info(f"[ASYNC_UPLOAD] üé® CSS pattern: {pattern} - found {len(elements)} elements")
                
                for element in elements:
                    if element and await is_valid_file_input_async(element):
                        log_info(f"[ASYNC_UPLOAD] [OK] Valid file input found with CSS pattern: {pattern}")
                        return element
                        
            except Exception as e:
                log_info(f"[ASYNC_UPLOAD] CSS pattern failed: {pattern} - {str(e)}")
                continue
                
        return None
    except Exception as e:
        log_info(f"[ASYNC_UPLOAD] CSS patterns search failed: {str(e)}")
        return None

async def find_input_via_broad_search_async(page):
    """–®–∏—Ä–æ–∫–∏–π –ø–æ–∏—Å–∫ –≤—Å–µ—Ö input —ç–ª–µ–º–µ–Ω—Ç–æ–≤ - –ü–û–õ–ù–ê–Ø –ö–û–ü–ò–Ø sync –≤–µ—Ä—Å–∏–∏"""
    try:
        # –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ input —ç–ª–µ–º–µ–Ω—Ç—ã –Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü–µ (–ü–û–õ–ù–ê–Ø –ö–û–ü–ò–Ø –∏–∑ sync)
        all_inputs = await page.query_selector_all('input')
        
        for input_element in all_inputs:
            try:
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–∞–∂–¥—ã–π input (–ü–û–õ–ù–ê–Ø –ö–û–ü–ò–Ø –∏–∑ sync)
                if await is_valid_file_input_async(input_element):
                    # –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ (–ü–û–õ–ù–ê–Ø –ö–û–ü–ò–Ø –∏–∑ sync)
                    input_classes = await input_element.get_attribute('class') or ""
                    input_accept = await input_element.get_attribute('accept') or ""
                    
                    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ accept —Å–æ–¥–µ—Ä–∂–∏—Ç –Ω—É–∂–Ω—ã–µ —Ç–∏–ø—ã —Ñ–∞–π–ª–æ–≤ (–ü–û–õ–ù–ê–Ø –ö–û–ü–ò–Ø –∏–∑ sync)
                    if any(file_type in input_accept.lower() for file_type in ['video', 'image', 'mp4', 'jpeg', 'png']):
                        log_info(f"[ASYNC_UPLOAD] Found valid file input: accept='{input_accept}', classes='{input_classes[:50]}'")
                        return input_element
                        
            except Exception as e:
                log_info(f"[ASYNC_UPLOAD] Error checking input element: {str(e)}")
                continue
                
        return None
    except Exception as e:
        log_info(f"[ASYNC_UPLOAD] Broad search failed: {str(e)}")
        return None

async def check_for_human_verification_dialog_async(page, account_details):
    """Check for human verification requirement - async version"""
    try:
        human_verification_indicators = [
            'div:has-text("–ü–æ–º–æ–≥–∏—Ç–µ –Ω–∞–º –ø–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å")',
            'div:has-text("Help us confirm")',
            'div:has-text("–ü–æ–¥–æ–∑—Ä–∏—Ç–µ–ª—å–Ω–∞—è –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å")',
            'div:has-text("Suspicious activity")',
            'div:has-text("–ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç–µ, —á—Ç–æ —ç—Ç–æ –≤—ã")',
            'div:has-text("Confirm it\'s you")',
        ]
        
        for selector in human_verification_indicators:
            try:
                element = await page.query_selector(selector)
                if element and await element.is_visible():
                    element_text = await element.text_content() or ""
                    log_info(f"[BOT] [ASYNC_VERIFICATION] Human verification detected: {element_text[:50]}")
                    return {
                        'requires_human_verification': True,
                        'message': f'Human verification required: {element_text[:100]}'
                    }
            except:
                continue
        
        return {'requires_human_verification': False}
        
    except Exception as e:
        log_error(f"[FAIL] [ASYNC_VERIFICATION] Error checking human verification: {str(e)}")
        return {'requires_human_verification': False}

__all__ = ['check_for_file_dialog_async', 'find_file_input_adaptive_async', 'is_valid_file_input_async', 'find_input_via_dialog_structure_async', 'find_input_via_button_async', 'find_input_via_form_context_async', 'find_input_via_css_patterns_async', 'find_input_via_broad_search_async', 'check_for_human_verification_dialog_async']


# === v2 strategy-based discovery (non-breaking additions) ===
from typing import Optional, Any, List
from .providers import register, strategies

# Try registering known strategies if they exist in this module
KNOWN = [
    "find_input_via_dialog_structure_async",
    "find_input_via_button_async",
    "find_input_via_form_context_async",
    "find_input_via_css_patterns_async",
    "find_input_via_broad_search_async",
]

for name in KNOWN:
    if name in globals() and callable(globals()[name]):
        register(globals()[name])

async def find_file_input_unified_v2_async(page, *, timeout: Optional[float] = None) -> Optional[Any]:
    """v2: iterate over registered strategies and return the first successful element/handle."""
    for provider in strategies():
        try:
            res = await provider(page, timeout=timeout) if "timeout" in provider.__code__.co_varnames else await provider(page)
            if res:
                return res
        except Exception:
            # keep parity with current permissive behavior
            continue
    return None


# === PASS 5 ADAPTIVE FILE INPUT SHIM (non-breaking) ===
try:
    _orig_find_file_input_adaptive_async = find_file_input_adaptive_async
except Exception:
    _orig_find_file_input_adaptive_async = None

from .logging import logger

async def find_file_input_adaptive_async(*args, **kwargs):
    """Try v2 unified file input first; fallback to original behavior."""
    try:
        from .file_input import find_file_input_unified_v2_async as _v2_unified
        res = await _v2_unified(*args, **kwargs)
        if res:
            return res
    except Exception as e:
        logger.debug("v2 unified file input failed: " + repr(e))
    if _orig_find_file_input_adaptive_async is not None:
        return await _orig_find_file_input_adaptive_async(*args, **kwargs)
    return None
